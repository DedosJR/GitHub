import path$1 from 'node:path';
import assert from 'node:assert';
import semver from 'semver';
import chalk from 'chalk';
import { packageManager } from '@strapi/utils';
import fse from 'fs-extra';
import fastglob from 'fast-glob';
import { run } from 'jscodeshift/src/Runner';
import { cloneDeep, get, has, merge, set, omit, isEqual, groupBy, size } from 'lodash/fp';
import { register } from 'esbuild-register/dist/node';
import simpleGit from 'simple-git';
import CliTable3 from 'cli-table3';

class Timer {
    get elapsedMs() {
        const { start, end } = this.interval;
        return end ? end - start : Date.now() - start;
    }
    get end() {
        return this.interval.end;
    }
    get start() {
        return this.interval.start;
    }
    stop() {
        this.interval.end = Date.now();
        return this.elapsedMs;
    }
    reset() {
        this.interval = {
            start: Date.now(),
            end: null
        };
        return this;
    }
    constructor(){
        this.reset();
    }
}
const timerFactory = ()=>new Timer();

const ONE_SECOND_MS = 1000;

var constants$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ONE_SECOND_MS: ONE_SECOND_MS
});

const path = (path)=>chalk.blue(path);
const version = (version)=>{
    return chalk.italic.yellow(`v${version}`);
};
const codemodUID = (uid)=>{
    return chalk.bold.cyan(uid);
};
const projectDetails = (project)=>{
    return `Project: TYPE=${projectType(project.type)}; CWD=${path(project.cwd)}; PATHS=${project.paths.map(path)}`;
};
const projectType = (type)=>chalk.cyan(type);
const versionRange = (range)=>chalk.italic.yellow(range.raw);
const transform = (transformFilePath)=>chalk.cyan(transformFilePath);
const highlight = (arg)=>chalk.bold.underline(arg);
const upgradeStep = (text, step)=>{
    return chalk.bold(`(${step[0]}/${step[1]}) ${text}...`);
};
const reports = (reports)=>{
    const rows = reports.map(({ codemod, report }, i)=>{
        const fIndex = chalk.grey(i);
        const fVersion = chalk.magenta(codemod.version);
        const fKind = chalk.yellow(codemod.kind);
        const fFormattedTransformPath = chalk.cyan(codemod.format());
        const fTimeElapsed = i === 0 ? `${report.timeElapsed}s ${chalk.dim.italic('(cold start)')}` : `${report.timeElapsed}s`;
        const fAffected = report.ok > 0 ? chalk.green(report.ok) : chalk.grey(0);
        const fUnchanged = report.ok === 0 ? chalk.red(report.nochange) : chalk.grey(report.nochange);
        return [
            fIndex,
            fVersion,
            fKind,
            fFormattedTransformPath,
            fAffected,
            fUnchanged,
            fTimeElapsed
        ];
    });
    const table = new CliTable3({
        style: {
            compact: true
        },
        head: [
            chalk.bold.grey('N°'),
            chalk.bold.magenta('Version'),
            chalk.bold.yellow('Kind'),
            chalk.bold.cyan('Name'),
            chalk.bold.green('Affected'),
            chalk.bold.red('Unchanged'),
            chalk.bold.blue('Duration')
        ]
    });
    table.push(...rows);
    return table.toString();
};
const codemodList = (codemods)=>{
    const rows = codemods.map((codemod, index)=>{
        const fIndex = chalk.grey(index);
        const fVersion = chalk.magenta(codemod.version);
        const fKind = chalk.yellow(codemod.kind);
        const fName = chalk.blue(codemod.format());
        const fUID = codemodUID(codemod.uid);
        return [
            fIndex,
            fVersion,
            fKind,
            fName,
            fUID
        ];
    });
    const table = new CliTable3({
        style: {
            compact: true
        },
        head: [
            chalk.bold.grey('N°'),
            chalk.bold.magenta('Version'),
            chalk.bold.yellow('Kind'),
            chalk.bold.blue('Name'),
            chalk.bold.cyan('UID')
        ]
    });
    table.push(...rows);
    return table.toString();
};
const durationMs = (elapsedMs)=>{
    const elapsedSeconds = (elapsedMs / ONE_SECOND_MS).toFixed(3);
    return `${elapsedSeconds}s`;
};

const NPM_REGISTRY_URL = 'https://registry.npmjs.org';

var ReleaseType;
(function(ReleaseType) {
    // Classic
    ReleaseType["Major"] = "major";
    ReleaseType["Minor"] = "minor";
    ReleaseType["Patch"] = "patch";
    // Other
    ReleaseType["Latest"] = "latest";
})(ReleaseType || (ReleaseType = {}));

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ReleaseType () { return ReleaseType; }
});

const semVerFactory = (version)=>{
    return new semver.SemVer(version);
};
const isLiteralSemVer = (str)=>{
    const tokens = str.split('.');
    return tokens.length === 3 && tokens.every((token)=>!Number.isNaN(+token) && Number.isInteger(+token));
};
const isValidSemVer = (str)=>semver.valid(str) !== null;
const isSemverInstance = (value)=>{
    return value instanceof semver.SemVer;
};
const isSemVerReleaseType = (str)=>{
    return Object.values(ReleaseType).includes(str);
};

const rangeFactory = (range)=>{
    return new semver.Range(range);
};
const rangeFromReleaseType = (current, identifier)=>{
    switch(identifier){
        case ReleaseType.Latest:
            {
                // Match anything greater than the current version
                return rangeFactory(`>${current.raw}`);
            }
        case ReleaseType.Major:
            {
                // For example, 4.15.4 returns 5.0.0
                const nextMajor = semVerFactory(current.raw).inc('major');
                // Using only the major version as the upper limit allows any minor,
                // patch, or build version to be taken in the range.
                //
                // For example, if the current version is "4.15.4", incrementing the
                // major version would result in "5.0.0".
                // The generated rule is ">4.15.4 <=5", allowing any version
                // greater than "4.15.4" but less than "6.0.0-0".
                return rangeFactory(`>${current.raw} <=${nextMajor.major}`);
            }
        case ReleaseType.Minor:
            {
                // For example, 4.15.4 returns 5.0.0
                const nextMajor = semVerFactory(current.raw).inc('major');
                // Using the <major>.<minor>.<patch> version as the upper limit allows any minor,
                // patch, or build versions to be taken in the range.
                //
                // For example, if the current version is "4.15.4", incrementing the
                // major version would result in "5.0.0".
                // The generated rule is ">4.15.4 <5.0.0", allowing any version
                // greater than "4.15.4" but less than "5.0.0".
                return rangeFactory(`>${current.raw} <${nextMajor.raw}`);
            }
        case ReleaseType.Patch:
            {
                // For example, 4.15.4 returns 4.16.0
                const nextMinor = semVerFactory(current.raw).inc('minor');
                // Using only the minor version as the upper limit allows any patch
                // or build versions to be taken in the range.
                //
                // For example, if the current version is "4.15.4", incrementing the
                // minor version would result in "4.16.0".
                // The generated rule is ">4.15.4 <4.16.0", allowing any version
                // greater than "4.15.4" but less than "4.16.0".
                return rangeFactory(`>${current.raw} <${nextMinor.raw}`);
            }
        default:
            {
                throw new Error('Not implemented');
            }
    }
};
const rangeFromVersions = (currentVersion, target)=>{
    if (isSemverInstance(target)) {
        return rangeFactory(`>${currentVersion.raw} <=${target.raw}`);
    }
    if (isSemVerReleaseType(target)) {
        return rangeFromReleaseType(currentVersion, target);
    }
    throw new Error(`Invalid target set: ${target}`); // TODO: better errors
};
const isValidStringifiedRange = (str)=>semver.validRange(str) !== null;
const isRangeInstance = (range)=>{
    return range instanceof semver.Range;
};

class Package {
    get isLoaded() {
        return this.npmPackage !== null;
    }
    assertPackageIsLoaded(npmPackage) {
        assert(this.isLoaded, 'The package is not loaded yet');
    }
    getVersionsDict() {
        this.assertPackageIsLoaded(this.npmPackage);
        return this.npmPackage.versions;
    }
    getVersionsAsList() {
        this.assertPackageIsLoaded(this.npmPackage);
        return Object.values(this.npmPackage.versions);
    }
    findVersionsInRange(range) {
        const versions = this.getVersionsAsList();
        return versions// Only select versions matching the upgrade range
        .filter((v)=>range.test(v.version))// Only select supported version format (x.x.x)
        .filter((v)=>isLiteralSemVer(v.version))// Sort in ascending order
        .sort((v1, v2)=>semver.compare(v1.version, v2.version));
    }
    findVersion(version) {
        const versions = this.getVersionsAsList();
        return versions.find((npmVersion)=>semver.eq(npmVersion.version, version));
    }
    async refresh() {
        const response = await fetch(this.packageURL);
        // TODO: Use a validation library to make sure the response structure is correct
        assert(response.ok, `Request failed for ${this.packageURL}`);
        this.npmPackage = await response.json();
        return this;
    }
    versionExists(version) {
        return this.findVersion(version) !== undefined;
    }
    constructor(name){
        this.name = name;
        this.packageURL = `${NPM_REGISTRY_URL}/${name}`;
        this.npmPackage = null;
    }
}
const npmPackageFactory = (name)=>new Package(name);

class FileScanner {
    scan(patterns) {
        // we use fastglob instead of glob because it supports negation patterns
        const filenames = fastglob.sync(patterns, {
            cwd: this.cwd
        });
        // Resolve the full paths for every filename
        return filenames.map((filename)=>path$1.join(this.cwd, filename));
    }
    constructor(cwd){
        this.cwd = cwd;
    }
}
const fileScannerFactory = (cwd)=>new FileScanner(cwd);

class AbstractRunner {
    async run(codemod, configuration) {
        const isValidCodemod = this.valid(codemod);
        if (!isValidCodemod) {
            throw new Error(`Invalid codemod provided to the runner: ${codemod.filename}`);
        }
        const runConfiguration = {
            ...this.configuration,
            ...configuration
        };
        return this.runner(codemod.path, this.paths, runConfiguration);
    }
    constructor(paths, configuration){
        this.paths = paths;
        this.configuration = configuration;
    }
}

class CodeRunner extends AbstractRunner {
    valid(codemod) {
        return codemod.kind === 'code';
    }
    constructor(...args){
        super(...args);
        this.runner = run;
    }
}
const codeRunnerFactory = (paths, configuration)=>{
    return new CodeRunner(paths, configuration);
};

class JSONTransformAPI {
    get(path, defaultValue) {
        if (!path) {
            return this.root();
        }
        return cloneDeep(get(path, this.json) ?? defaultValue);
    }
    has(path) {
        return has(path, this.json);
    }
    merge(other) {
        this.json = merge(other, this.json);
        return this;
    }
    root() {
        return cloneDeep(this.json);
    }
    set(path, value) {
        this.json = set(path, value, this.json);
        return this;
    }
    remove(path) {
        this.json = omit(path, this.json);
        return this;
    }
    constructor(json){
        this.json = cloneDeep(json);
    }
}
const createJSONTransformAPI = (object)=>new JSONTransformAPI(object);

const readJSON = async (path)=>{
    const buffer = await fse.readFile(path);
    return JSON.parse(buffer.toString());
};
const saveJSON = async (path, json)=>{
    const jsonAsString = `${JSON.stringify(json, null, 2)}\n`;
    await fse.writeFile(path, jsonAsString);
};

const transformJSON = async (codemodPath, paths, config)=>{
    const { dry } = config;
    const startTime = process.hrtime();
    const report = {
        ok: 0,
        nochange: 0,
        skip: 0,
        error: 0,
        timeElapsed: '',
        stats: {}
    };
    /**
   * Why do we need to include node_modules (hookIgnoreNodeModules) and specify a matcher (hookMatcher) to esbuild?
   *
   * When using tools like npx or dlx, the execution context is different from when running the program in a local
   * project. npx and dlx run the commands in a temporary installation, which is isolated from local project files.
   *
   * When hookIgnoreNodeModules is not specified (or set to true), esbuild-register instructs
   * Pirates (https://github.com/danez/pirates) to not transpile any files that come from node_modules.
   *
   * Now, when using npx or dlx to run a script, its location can be seen as "external" because it's not part of
   * the temporary environment where npx or dlx execute. Therefore, it's considered to be part of node_modules.
   *
   * Due to this, if hookIgnoreNodeModules is set to true or left unspecified,
   * esbuild-register won't try to compile them upon require.
   *
   * hookMatcher is added to make sure we're not matching anything else than our codemod in external directories.
   */ const esbuildOptions = {
        extensions: [
            '.js',
            '.mjs',
            '.ts'
        ],
        hookIgnoreNodeModules: false,
        hookMatcher: isEqual(codemodPath)
    };
    const { unregister } = register(esbuildOptions);
    const module = require(codemodPath);
    unregister();
    const codemod = typeof module.default === 'function' ? module.default : module;
    assert(typeof codemod === 'function', `Codemod must be a function. Found ${typeof codemod}`);
    for (const path of paths){
        try {
            const json = await readJSON(path);
            // Make sure the JSON value is a JSON object
            assert(typeof json === 'object' && !Array.isArray(json) && json !== null);
            // TODO: Optimize the API to limit parse/stringify operations
            const file = {
                path,
                json
            };
            const params = {
                cwd: config.cwd,
                json: createJSONTransformAPI
            };
            const out = await codemod(file, params);
            if (out === undefined) {
                report.error += 1;
            } else if (!isEqual(json, out)) {
                if (!dry) {
                    await saveJSON(path, out);
                }
                report.ok += 1;
            } else {
                report.nochange += 1;
            }
        } catch  {
            report.error += 1;
        }
    }
    const endTime = process.hrtime(startTime);
    report.timeElapsed = (endTime[0] + endTime[1] / 1e9).toFixed(3);
    return report;
};

class JSONRunner extends AbstractRunner {
    valid(codemod) {
        return codemod.kind === 'json';
    }
    constructor(...args){
        super(...args);
        this.runner = transformJSON;
    }
}
const jsonRunnerFactory = (paths, configuration)=>{
    return new JSONRunner(paths, configuration);
};

const PROJECT_PACKAGE_JSON = 'package.json';
const PROJECT_APP_ALLOWED_ROOT_PATHS = [
    'src',
    'config',
    'public'
];
const PROJECT_PLUGIN_ALLOWED_ROOT_PATHS = [
    'admin',
    'server'
];
const PROJECT_PLUGIN_ROOT_FILES = [
    'strapi-admin.js',
    'strapi-server.js'
];
const PROJECT_CODE_EXTENSIONS = [
    // Source files
    'js',
    'mjs',
    'ts',
    // React files
    'jsx',
    'tsx'
];
const PROJECT_JSON_EXTENSIONS = [
    'json'
];
const PROJECT_ALLOWED_EXTENSIONS = [
    ...PROJECT_CODE_EXTENSIONS,
    ...PROJECT_JSON_EXTENSIONS
];
const SCOPED_STRAPI_PACKAGE_PREFIX = '@strapi/';
const STRAPI_DEPENDENCY_NAME = `${SCOPED_STRAPI_PACKAGE_PREFIX}strapi`;

var constants$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  PROJECT_ALLOWED_EXTENSIONS: PROJECT_ALLOWED_EXTENSIONS,
  PROJECT_APP_ALLOWED_ROOT_PATHS: PROJECT_APP_ALLOWED_ROOT_PATHS,
  PROJECT_CODE_EXTENSIONS: PROJECT_CODE_EXTENSIONS,
  PROJECT_JSON_EXTENSIONS: PROJECT_JSON_EXTENSIONS,
  PROJECT_PACKAGE_JSON: PROJECT_PACKAGE_JSON,
  PROJECT_PLUGIN_ALLOWED_ROOT_PATHS: PROJECT_PLUGIN_ALLOWED_ROOT_PATHS,
  PROJECT_PLUGIN_ROOT_FILES: PROJECT_PLUGIN_ROOT_FILES,
  SCOPED_STRAPI_PACKAGE_PREFIX: SCOPED_STRAPI_PACKAGE_PREFIX,
  STRAPI_DEPENDENCY_NAME: STRAPI_DEPENDENCY_NAME
});

class Project {
    getFilesByExtensions(extensions) {
        return this.files.filter((filePath)=>{
            const fileExtension = path$1.extname(filePath);
            return extensions.includes(fileExtension);
        });
    }
    refresh() {
        this.refreshPackageJSON();
        this.refreshProjectFiles();
        return this;
    }
    async runCodemods(codemods, options) {
        const runners = this.createProjectCodemodsRunners(options.dry);
        const reports = [];
        for (const codemod of codemods){
            for (const runner of runners){
                if (runner.valid(codemod)) {
                    const report = await runner.run(codemod);
                    reports.push({
                        codemod,
                        report
                    });
                }
            }
        }
        return reports;
    }
    createProjectCodemodsRunners(dry = false) {
        const jsonExtensions = PROJECT_JSON_EXTENSIONS.map((ext)=>`.${ext}`);
        const codeExtensions = PROJECT_CODE_EXTENSIONS.map((ext)=>`.${ext}`);
        const jsonFiles = this.getFilesByExtensions(jsonExtensions);
        const codeFiles = this.getFilesByExtensions(codeExtensions);
        const codeRunner = codeRunnerFactory(codeFiles, {
            dry,
            parser: 'ts',
            runInBand: true,
            babel: true,
            extensions: PROJECT_CODE_EXTENSIONS.join(','),
            // Don't output any log coming from the runner
            print: false,
            silent: true,
            verbose: 0
        });
        const jsonRunner = jsonRunnerFactory(jsonFiles, {
            dry,
            cwd: this.cwd
        });
        return [
            codeRunner,
            jsonRunner
        ];
    }
    refreshPackageJSON() {
        const packageJSONPath = path$1.join(this.cwd, PROJECT_PACKAGE_JSON);
        try {
            fse.accessSync(packageJSONPath);
        } catch  {
            throw new Error(`Could not find a ${PROJECT_PACKAGE_JSON} file in ${this.cwd}`);
        }
        const packageJSONBuffer = fse.readFileSync(packageJSONPath);
        this.packageJSONPath = packageJSONPath;
        this.packageJSON = JSON.parse(packageJSONBuffer.toString());
    }
    refreshProjectFiles() {
        const scanner = fileScannerFactory(this.cwd);
        this.files = scanner.scan(this.paths);
    }
    constructor(cwd, config){
        if (!fse.pathExistsSync(cwd)) {
            throw new Error(`ENOENT: no such file or directory, access '${cwd}'`);
        }
        this.cwd = cwd;
        this.paths = config.paths;
        this.refresh();
    }
}
class AppProject extends Project {
    /**
   * Returns an array of allowed file paths for a Strapi application
   *
   * The resulting paths include app default files and the root package.json file.
   */ static get paths() {
        const allowedRootPaths = formatGlobCollectionPattern(PROJECT_APP_ALLOWED_ROOT_PATHS);
        const allowedExtensions = formatGlobCollectionPattern(PROJECT_ALLOWED_EXTENSIONS);
        return [
            // App default files
            `./${allowedRootPaths}/**/*.${allowedExtensions}`,
            `!./**/node_modules/**/*`,
            `!./**/dist/**/*`,
            // Root package.json file
            PROJECT_PACKAGE_JSON
        ];
    }
    refresh() {
        super.refresh();
        this.refreshStrapiVersion();
        return this;
    }
    refreshStrapiVersion() {
        this.strapiVersion = // First try to get the strapi version from the package.json dependencies
        this.findStrapiVersionFromProjectPackageJSON() ?? // If the version found is not a valid SemVer, get the Strapi version from the installed package
        this.findLocallyInstalledStrapiVersion();
    }
    findStrapiVersionFromProjectPackageJSON() {
        const projectName = this.packageJSON.name;
        const version = this.packageJSON.dependencies?.[STRAPI_DEPENDENCY_NAME];
        if (version === undefined) {
            throw new Error(`No version of ${STRAPI_DEPENDENCY_NAME} was found in ${projectName}. Are you in a valid Strapi project?`);
        }
        const isValidSemVer = isLiteralSemVer(version) && semver.valid(version) === version;
        // We return undefined only if a strapi/strapi version is found, but it's not semver compliant
        return isValidSemVer ? semVerFactory(version) : undefined;
    }
    findLocallyInstalledStrapiVersion() {
        const packageSearchText = `${STRAPI_DEPENDENCY_NAME}/package.json`;
        let strapiPackageJSONPath;
        let strapiPackageJSON;
        try {
            strapiPackageJSONPath = require.resolve(packageSearchText, {
                paths: [
                    this.cwd
                ]
            });
            strapiPackageJSON = require(strapiPackageJSONPath);
            assert(typeof strapiPackageJSON === 'object');
        } catch  {
            throw new Error(`Cannot resolve module "${STRAPI_DEPENDENCY_NAME}" from paths [${this.cwd}]`);
        }
        const strapiVersion = strapiPackageJSON.version;
        if (!isValidSemVer(strapiVersion)) {
            throw new Error(`Invalid ${STRAPI_DEPENDENCY_NAME} version found in ${strapiPackageJSONPath} (${strapiVersion})`);
        }
        return semVerFactory(strapiVersion);
    }
    constructor(cwd){
        super(cwd, {
            paths: AppProject.paths
        });
        this.type = 'application';
        this.refreshStrapiVersion();
    }
}
const formatGlobCollectionPattern = (collection)=>{
    assert(collection.length > 0, 'Invalid pattern provided, the given collection needs at least 1 element');
    return collection.length === 1 ? collection[0] : `{${collection}}`;
};
class PluginProject extends Project {
    /**
   * Returns an array of allowed file paths for a Strapi plugin
   *
   * The resulting paths include plugin default files, the root package.json file, and plugin-specific files.
   */ static get paths() {
        const allowedRootPaths = formatGlobCollectionPattern(PROJECT_PLUGIN_ALLOWED_ROOT_PATHS);
        const allowedExtensions = formatGlobCollectionPattern(PROJECT_ALLOWED_EXTENSIONS);
        return [
            // Plugin default files
            `./${allowedRootPaths}/**/*.${allowedExtensions}`,
            `!./**/node_modules/**/*`,
            `!./**/dist/**/*`,
            // Root package.json file
            PROJECT_PACKAGE_JSON,
            // Plugin root files
            ...PROJECT_PLUGIN_ROOT_FILES
        ];
    }
    constructor(cwd){
        super(cwd, {
            paths: PluginProject.paths
        });
        this.type = 'plugin';
    }
}
const isPlugin = (cwd)=>{
    const packageJSONPath = path$1.join(cwd, PROJECT_PACKAGE_JSON);
    try {
        fse.accessSync(packageJSONPath);
    } catch  {
        throw new Error(`Could not find a ${PROJECT_PACKAGE_JSON} file in ${cwd}`);
    }
    const packageJSONBuffer = fse.readFileSync(packageJSONPath);
    const packageJSON = JSON.parse(packageJSONBuffer.toString());
    return packageJSON?.strapi?.kind === 'plugin';
};
// TODO: make this async so we can use async file methods
const projectFactory = (cwd)=>{
    fse.accessSync(cwd);
    return isPlugin(cwd) ? new PluginProject(cwd) : new AppProject(cwd);
};

const isPluginProject = (project)=>{
    return project instanceof PluginProject;
};
function assertPluginProject(project) {
    if (!isPluginProject(project)) {
        throw new Error('Project is not a plugin');
    }
}
const isApplicationProject = (project)=>{
    return project instanceof AppProject;
};
function assertAppProject(project) {
    if (!isApplicationProject(project)) {
        throw new Error('Project is not an application');
    }
}

class UnexpectedError extends Error {
    constructor(){
        super('Unexpected Error');
    }
}
class NPMCandidateNotFoundError extends Error {
    constructor(target, message = `Couldn't find a valid NPM candidate for "${target}"`){
        super(message);
        this.target = target;
    }
}
class AbortedError extends Error {
    constructor(message = 'Upgrade aborted'){
        super(message);
    }
}
const unknownToError = (e)=>{
    if (e instanceof Error) {
        return e;
    }
    if (typeof e === 'string') {
        return new Error(e);
    }
    return new UnexpectedError();
};

const CODEMOD_CODE_SUFFIX = 'code';
const CODEMOD_JSON_SUFFIX = 'json';
const CODEMOD_ALLOWED_SUFFIXES = [
    CODEMOD_CODE_SUFFIX,
    CODEMOD_JSON_SUFFIX
];
const CODEMOD_EXTENSION = 'ts';
const CODEMOD_FILE_REGEXP = new RegExp(`^.+[.](${CODEMOD_ALLOWED_SUFFIXES.join('|')})[.]${CODEMOD_EXTENSION}$`);

var constants$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CODEMOD_ALLOWED_SUFFIXES: CODEMOD_ALLOWED_SUFFIXES,
  CODEMOD_CODE_SUFFIX: CODEMOD_CODE_SUFFIX,
  CODEMOD_EXTENSION: CODEMOD_EXTENSION,
  CODEMOD_FILE_REGEXP: CODEMOD_FILE_REGEXP,
  CODEMOD_JSON_SUFFIX: CODEMOD_JSON_SUFFIX
});

class Codemod {
    createUID() {
        const name = this.format({
            stripExtension: true,
            stripKind: true,
            stripHyphens: false
        });
        const kind = this.kind;
        const version = this.version.raw;
        return `${version}-${name}-${kind}`;
    }
    format(options) {
        const { stripExtension = true, stripKind = true, stripHyphens = true } = options ?? {};
        let formatted = this.filename;
        if (stripExtension) {
            formatted = formatted.replace(new RegExp(`\\.${CODEMOD_EXTENSION}$`, 'i'), '');
        }
        if (stripKind) {
            formatted = formatted.replace(`.${CODEMOD_CODE_SUFFIX}`, '').replace(`.${CODEMOD_JSON_SUFFIX}`, '');
        }
        if (stripHyphens) {
            formatted = formatted.replaceAll('-', ' ');
        }
        return formatted;
    }
    constructor(options){
        this.kind = options.kind;
        this.version = options.version;
        this.baseDirectory = options.baseDirectory;
        this.filename = options.filename;
        this.path = path$1.join(this.baseDirectory, this.version.raw, this.filename);
        this.uid = this.createUID();
    }
}
const codemodFactory = (options)=>new Codemod(options);

const INTERNAL_CODEMODS_DIRECTORY = path$1.join(__dirname, '..', '..', 'resources', 'codemods' // upgrade/resources/codemods
);

var constants$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INTERNAL_CODEMODS_DIRECTORY: INTERNAL_CODEMODS_DIRECTORY
});

class CodemodRepository {
    refresh() {
        this.refreshAvailableVersions();
        this.refreshAvailableFiles();
        return this;
    }
    count(version) {
        return this.findByVersion(version).length;
    }
    versionExists(version) {
        return version.raw in this.groups;
    }
    has(uid) {
        const result = this.find({
            uids: [
                uid
            ]
        });
        if (result.length !== 1) {
            return false;
        }
        const { codemods } = result[0];
        return codemods.length === 1 && codemods[0].uid === uid;
    }
    find(q) {
        const entries = Object.entries(this.groups);
        return entries// Filter by range if provided in the query
        .filter(maybeFilterByRange)// Transform version/codemods tuples into regular objects
        .map(([version, codemods])=>({
                version: semVerFactory(version),
                // Filter by UID if provided in the query
                codemods: codemods.filter(maybeFilterByUIDs)
            }))// Only return groups with at least 1 codemod
        .filter(({ codemods })=>codemods.length > 0);
        function maybeFilterByRange([version]) {
            if (!isRangeInstance(q.range)) {
                return true;
            }
            return q.range.test(version);
        }
        function maybeFilterByUIDs(codemod) {
            if (q.uids === undefined) {
                return true;
            }
            return q.uids.includes(codemod.uid);
        }
    }
    findByVersion(version) {
        const literalVersion = version.raw;
        const codemods = this.groups[literalVersion];
        return codemods ?? [];
    }
    findAll() {
        const entries = Object.entries(this.groups);
        return entries.map(([version, codemods])=>({
                version: semVerFactory(version),
                codemods
            }));
    }
    refreshAvailableVersions() {
        this.versions = fse.readdirSync(this.cwd) // Only keep root directories
        .filter((filename)=>fse.statSync(path$1.join(this.cwd, filename)).isDirectory())// Paths should be valid semver
        .filter((filename)=>semver.valid(filename) !== null)// Transform files names to SemVer instances
        .map((version)=>semVerFactory(version))// Sort versions in ascending order
        .sort(semver.compare);
        return this;
    }
    refreshAvailableFiles() {
        this.groups = {};
        for (const version of this.versions){
            this.refreshAvailableFilesForVersion(version);
        }
    }
    refreshAvailableFilesForVersion(version) {
        const literalVersion = version.raw;
        const versionDirectory = path$1.join(this.cwd, literalVersion);
        // Ignore obsolete versions
        if (!fse.existsSync(versionDirectory)) {
            return;
        }
        this.groups[literalVersion] = fse.readdirSync(versionDirectory)// Make sure the filenames are valid codemod files
        .filter((filename)=>fse.statSync(path$1.join(versionDirectory, filename)).isFile()).filter((filename)=>CODEMOD_FILE_REGEXP.test(filename))// Transform the filenames into Codemod instances
        .map((filename)=>{
            const kind = parseCodemodKindFromFilename(filename);
            const baseDirectory = this.cwd;
            return codemodFactory({
                kind,
                baseDirectory,
                version,
                filename
            });
        });
    }
    constructor(cwd){
        assert(fse.existsSync(cwd), `Invalid codemods directory provided "${cwd}"`);
        this.cwd = cwd;
        this.groups = {};
        this.versions = [];
    }
}
const parseCodemodKindFromFilename = (filename)=>{
    const kind = filename.split('.').at(-2);
    assert(kind !== undefined);
    assert(CODEMOD_ALLOWED_SUFFIXES.includes(kind));
    return kind;
};
const codemodRepositoryFactory = (cwd = INTERNAL_CODEMODS_DIRECTORY)=>{
    return new CodemodRepository(cwd);
};

class CodemodRunner {
    setRange(range) {
        this.range = range;
        return this;
    }
    setLogger(logger) {
        this.logger = logger;
        return this;
    }
    onSelectCodemods(callback) {
        this.selectCodemodsCallback = callback;
        return this;
    }
    dry(enabled = true) {
        this.isDry = enabled;
        return this;
    }
    createRepository(codemodsDirectory) {
        const repository = codemodRepositoryFactory(codemodsDirectory ?? INTERNAL_CODEMODS_DIRECTORY);
        // Make sure we have access to the latest snapshots of codemods on the system
        repository.refresh();
        return repository;
    }
    async safeRunAndReport(codemods) {
        if (this.isDry) {
            this.logger?.warn?.('Running the codemods in dry mode. No files will be modified during the process.');
        }
        try {
            const reports$1 = await this.project.runCodemods(codemods, {
                dry: this.isDry
            });
            this.logger?.raw?.(reports(reports$1));
            if (!this.isDry) {
                const nbAffectedTotal = reports$1.flatMap((report)=>report.report.ok).reduce((acc, nb)=>acc + nb, 0);
                this.logger?.debug?.(`Successfully ran ${highlight(codemods.length)} codemod(s), ${highlight(nbAffectedTotal)} change(s) have been detected`);
            }
            return successReport$1();
        } catch (e) {
            return erroredReport$1(unknownToError(e));
        }
    }
    async runByUID(uid, codemodsDirectory) {
        const repository = this.createRepository(codemodsDirectory);
        if (!repository.has(uid)) {
            throw new Error(`Unknown codemod UID provided: ${uid}`);
        }
        // Note: Ignore the range when running with a UID
        const codemods = repository.find({
            uids: [
                uid
            ]
        }).flatMap(({ codemods })=>codemods);
        return this.safeRunAndReport(codemods);
    }
    async run(codemodsDirectory) {
        const repository = this.createRepository(codemodsDirectory);
        // Find codemods matching the given range
        const codemodsInRange = repository.find({
            range: this.range
        });
        // If a selection callback is set, use it, else keep every codemods found
        const selectedCodemods = this.selectCodemodsCallback ? await this.selectCodemodsCallback(codemodsInRange) : codemodsInRange;
        // If no codemods have been selected (either manually or automatically)
        // Then ignore and return a successful report
        if (selectedCodemods.length === 0) {
            this.logger?.debug?.(`Found no codemods to run for ${versionRange(this.range)}`);
            return successReport$1();
        }
        // Flatten the collection to a single list of codemods, the original list should already be sorted by version
        const codemods = selectedCodemods.flatMap(({ codemods })=>codemods);
        // Log (debug) the codemods by version
        const codemodsByVersion = groupBy('version', codemods);
        const fRange = versionRange(this.range);
        this.logger?.debug?.(`Found ${highlight(codemods.length)} codemods for ${highlight(size(codemodsByVersion))} version(s) using ${fRange}`);
        for (const [version$1, codemods] of Object.entries(codemodsByVersion)){
            this.logger?.debug?.(`- ${version(semVerFactory(version$1))} (${codemods.length})`);
        }
        return this.safeRunAndReport(codemods);
    }
    constructor(project, range){
        this.project = project;
        this.range = range;
        this.isDry = false;
        this.logger = null;
        this.selectCodemodsCallback = null;
    }
}
const codemodRunnerFactory = (project, range)=>{
    return new CodemodRunner(project, range);
};
const successReport$1 = ()=>({
        success: true,
        error: null
    });
const erroredReport$1 = (error)=>({
        success: false,
        error
    });

class Upgrader {
    getNPMPackage() {
        return this.npmPackage;
    }
    getProject() {
        return this.project;
    }
    getTarget() {
        return semVerFactory(this.target.raw);
    }
    setRequirements(requirements) {
        this.requirements = requirements;
        return this;
    }
    setTarget(target) {
        this.target = target;
        return this;
    }
    syncCodemodsTarget() {
        // Extract the <major>.<minor>.<patch> version from the target and assign it to the codemods target
        //
        // This is useful when dealing with alphas, betas or release candidates:
        // e.g. "5.0.0-beta.951" becomes "5.0.0"
        //
        // For experimental versions (e.g. "0.0.0-experimental.hex"), it is necessary to
        // override the codemods target manually in order to run the appropriate ones.
        this.codemodsTarget = semVerFactory(`${this.target.major}.${this.target.minor}.${this.target.patch}`);
        this.logger?.debug?.(`The codemods target has been synced with the upgrade target. The codemod runner will now look for ${version(this.codemodsTarget)}`);
        return this;
    }
    overrideCodemodsTarget(target) {
        this.codemodsTarget = target;
        this.logger?.debug?.(`Overriding the codemods target. The codemod runner will now look for ${version(target)}`);
        return this;
    }
    setLogger(logger) {
        this.logger = logger;
        return this;
    }
    onConfirm(callback) {
        this.confirmationCallback = callback;
        return this;
    }
    dry(enabled = true) {
        this.isDry = enabled;
        return this;
    }
    addRequirement(requirement) {
        this.requirements.push(requirement);
        const fRequired = requirement.isRequired ? '(required)' : '(optional)';
        this.logger?.debug?.(`Added a new requirement to the upgrade: ${highlight(requirement.name)} ${fRequired}`);
        return this;
    }
    async upgrade() {
        this.logger?.info?.(`Upgrading from ${version(this.project.strapiVersion)} to ${version(this.target)}`);
        if (this.isDry) {
            this.logger?.warn?.('Running the upgrade in dry mode. No files will be modified during the process.');
        }
        const range = rangeFromVersions(this.project.strapiVersion, this.target);
        const codemodsRange = rangeFromVersions(this.project.strapiVersion, this.codemodsTarget);
        const npmVersionsMatches = this.npmPackage?.findVersionsInRange(range) ?? [];
        this.logger?.debug?.(`Found ${highlight(npmVersionsMatches.length)} versions satisfying ${versionRange(range)}`);
        try {
            this.logger?.info?.(upgradeStep('Checking requirement', [
                1,
                4
            ]));
            await this.checkRequirements(this.requirements, {
                npmVersionsMatches,
                project: this.project,
                target: this.target
            });
            this.logger?.info?.(upgradeStep('Applying the latest code modifications', [
                2,
                4
            ]));
            await this.runCodemods(codemodsRange);
            // We need to refresh the project files to make sure we have
            // the latest version of each file (including package.json) for the next steps
            this.logger?.debug?.('Refreshing project information...');
            this.project.refresh();
            this.logger?.info?.(upgradeStep('Upgrading Strapi dependencies', [
                3,
                4
            ]));
            await this.updateDependencies();
            this.logger?.info?.(upgradeStep('Installing dependencies', [
                4,
                4
            ]));
            await this.installDependencies();
        } catch (e) {
            return erroredReport(unknownToError(e));
        }
        return successReport();
    }
    async confirm(message) {
        if (typeof this.confirmationCallback !== 'function') {
            return true;
        }
        return this.confirmationCallback(message);
    }
    async checkRequirements(requirements, context) {
        for (const requirement of requirements){
            const { pass, error } = await requirement.test(context);
            if (pass) {
                await this.onSuccessfulRequirement(requirement, context);
            } else {
                await this.onFailedRequirement(requirement, error);
            }
        }
    }
    async onSuccessfulRequirement(requirement, context) {
        const hasChildren = requirement.children.length > 0;
        if (hasChildren) {
            await this.checkRequirements(requirement.children, context);
        }
    }
    async onFailedRequirement(requirement, originalError) {
        const errorMessage = `Requirement failed: ${originalError.message} (${highlight(requirement.name)})`;
        const warningMessage = originalError.message;
        const confirmationMessage = `Ignore optional requirement "${highlight(requirement.name)}" ?`;
        const error = new Error(errorMessage);
        if (requirement.isRequired) {
            throw error;
        }
        this.logger?.warn?.(warningMessage);
        const response = await this.confirmationCallback?.(confirmationMessage);
        if (!response) {
            throw error;
        }
    }
    async updateDependencies() {
        const { packageJSON, packageJSONPath } = this.project;
        const json = createJSONTransformAPI(packageJSON);
        const dependencies = json.get('dependencies', {});
        const strapiDependencies = this.getScopedStrapiDependencies(dependencies);
        this.logger?.debug?.(`Found ${highlight(strapiDependencies.length)} dependency(ies) to update`);
        strapiDependencies.forEach((dependency)=>this.logger?.debug?.(`- ${dependency[0]} (${dependency[1]} -> ${this.target})`));
        if (strapiDependencies.length === 0) {
            return;
        }
        strapiDependencies.forEach(([name])=>json.set(`dependencies.${name}`, this.target.raw));
        const updatedPackageJSON = json.root();
        if (this.isDry) {
            this.logger?.debug?.(`Skipping dependencies update (${chalk.italic('dry mode')})`);
            return;
        }
        await saveJSON(packageJSONPath, updatedPackageJSON);
    }
    getScopedStrapiDependencies(dependencies) {
        const { strapiVersion } = this.project;
        const strapiDependencies = [];
        // Find all @strapi/* packages matching the current Strapi version
        for (const [name, version] of Object.entries(dependencies)){
            const isScopedStrapiPackage = name.startsWith(SCOPED_STRAPI_PACKAGE_PREFIX);
            const isOnCurrentStrapiVersion = isValidSemVer(version) && version === strapiVersion.raw;
            if (isScopedStrapiPackage && isOnCurrentStrapiVersion) {
                strapiDependencies.push([
                    name,
                    semVerFactory(version)
                ]);
            }
        }
        return strapiDependencies;
    }
    async installDependencies() {
        const projectPath = this.project.cwd;
        const packageManagerName = await packageManager.getPreferred(projectPath);
        this.logger?.debug?.(`Using ${highlight(packageManagerName)} as package manager`);
        if (this.isDry) {
            this.logger?.debug?.(`Skipping dependencies installation (${chalk.italic('dry mode')})`);
            return;
        }
        await packageManager.installDependencies(projectPath, packageManagerName, {
            stdout: this.logger?.stdout,
            stderr: this.logger?.stderr
        });
    }
    async runCodemods(range) {
        const codemodRunner = codemodRunnerFactory(this.project, range);
        codemodRunner.dry(this.isDry);
        if (this.logger) {
            codemodRunner.setLogger(this.logger);
        }
        await codemodRunner.run();
    }
    constructor(project, target, npmPackage){
        this.project = project;
        this.npmPackage = npmPackage;
        this.target = target;
        this.syncCodemodsTarget();
        this.isDry = false;
        this.requirements = [];
        this.logger = null;
        this.confirmationCallback = null;
    }
}
/**
 * Resolves the NPM target version based on the given project, target, and NPM package.
 * If target is a SemVer, it directly finds it. If it's a release type (major, minor, patch),
 * it calculates the range of versions for this release type and returns the latest version within this range.
 */ const resolveNPMTarget = (project, target, npmPackage)=>{
    // Semver
    if (isSemverInstance(target)) {
        const version = npmPackage.findVersion(target);
        if (!version) {
            throw new NPMCandidateNotFoundError(target);
        }
        return version;
    }
    // Release Types
    if (isSemVerReleaseType(target)) {
        const range = rangeFromVersions(project.strapiVersion, target);
        const npmVersionsMatches = npmPackage.findVersionsInRange(range);
        // The targeted version is the latest one that matches the given range
        const version = npmVersionsMatches.at(-1);
        if (!version) {
            throw new NPMCandidateNotFoundError(range, `The project is already up-to-date (${target})`);
        }
        return version;
    }
    throw new NPMCandidateNotFoundError(target);
};
const upgraderFactory = (project, target, npmPackage)=>{
    const npmTarget = resolveNPMTarget(project, target, npmPackage);
    const semverTarget = semVerFactory(npmTarget.version);
    if (semver.eq(semverTarget, project.strapiVersion)) {
        throw new Error(`The project is already using v${semverTarget}`);
    }
    return new Upgrader(project, semverTarget, npmPackage);
};
const successReport = ()=>({
        success: true,
        error: null
    });
const erroredReport = (error)=>({
        success: false,
        error
    });

const STRAPI_PACKAGE_NAME = '@strapi/strapi';

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  STRAPI_PACKAGE_NAME: STRAPI_PACKAGE_NAME
});

class Requirement {
    setChildren(children) {
        this.children = children;
        return this;
    }
    addChild(child) {
        this.children.push(child);
        return this;
    }
    asOptional() {
        const newInstance = requirementFactory(this.name, this.testCallback, false);
        newInstance.setChildren(this.children);
        return newInstance;
    }
    asRequired() {
        const newInstance = requirementFactory(this.name, this.testCallback, true);
        newInstance.setChildren(this.children);
        return newInstance;
    }
    async test(context) {
        try {
            await this.testCallback?.(context);
            return ok();
        } catch (e) {
            if (e instanceof Error) {
                return errored(e);
            }
            if (typeof e === 'string') {
                return errored(new Error(e));
            }
            return errored(new Error('Unknown error'));
        }
    }
    constructor(name, testCallback, isRequired){
        this.name = name;
        this.testCallback = testCallback;
        this.isRequired = isRequired ?? true;
        this.children = [];
    }
}
const ok = ()=>({
        pass: true,
        error: null
    });
const errored = (error)=>({
        pass: false,
        error
    });
const requirementFactory = (name, testCallback, isRequired)=>new Requirement(name, testCallback, isRequired);

const REQUIRE_AVAILABLE_NEXT_MAJOR = requirementFactory('REQUIRE_AVAILABLE_NEXT_MAJOR', (context)=>{
    const { project, target } = context;
    const currentMajor = project.strapiVersion.major;
    const targetedMajor = target.major;
    if (targetedMajor === currentMajor) {
        throw new Error(`You're already on the latest major version (v${currentMajor})`);
    }
});
const REQUIRE_LATEST_FOR_CURRENT_MAJOR = requirementFactory('REQUIRE_LATEST_FOR_CURRENT_MAJOR', (context)=>{
    const { project, target, npmVersionsMatches } = context;
    const { major: currentMajor } = project.strapiVersion;
    const invalidMatches = npmVersionsMatches.filter((match)=>semVerFactory(match.version).major === currentMajor);
    if (invalidMatches.length > 0) {
        const invalidVersions = invalidMatches.map((match)=>match.version);
        const invalidVersionsCount = invalidVersions.length;
        throw new Error(`Doing a major upgrade requires to be on the latest v${currentMajor} version, but found ${invalidVersionsCount} versions between the current one and ${target}. Please upgrade to ${invalidVersions.at(-1)} and try again.`);
    }
});

const REQUIRE_GIT_CLEAN_REPOSITORY = requirementFactory('REQUIRE_GIT_CLEAN_REPOSITORY', async (context)=>{
    const git = simpleGit({
        baseDir: context.project.cwd
    });
    const status = await git.status();
    if (!status.isClean()) {
        throw new Error('Repository is not clean. Please commit or stash any changes before upgrading');
    }
});
const REQUIRE_GIT_REPOSITORY = requirementFactory('REQUIRE_GIT_REPOSITORY', async (context)=>{
    const git = simpleGit({
        baseDir: context.project.cwd
    });
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
        throw new Error('Not a git repository (or any of the parent directories)');
    }
}).addChild(REQUIRE_GIT_CLEAN_REPOSITORY.asOptional());
const REQUIRE_GIT_INSTALLED = requirementFactory('REQUIRE_GIT_INSTALLED', async (context)=>{
    const git = simpleGit({
        baseDir: context.project.cwd
    });
    try {
        await git.version();
    } catch  {
        throw new Error('Git is not installed');
    }
}).addChild(REQUIRE_GIT_REPOSITORY.asOptional());
const REQUIRE_GIT = requirementFactory('REQUIRE_GIT', null).addChild(REQUIRE_GIT_INSTALLED.asOptional());

/**
 * Handles the upgrade prompts when using the latest tag.
 *
 * - checks if an upgrade involves a major bump, warning and asking for user confirmation before proceeding
 */ const latest = async (upgrader, options)=>{
    // Exit if the upgrade target isn't the latest tag
    if (options.target !== ReleaseType.Latest) {
        return;
    }
    // Retrieve utilities from the upgrader instance
    const npmPackage = upgrader.getNPMPackage();
    const target = upgrader.getTarget();
    const project = upgrader.getProject();
    const { strapiVersion: current } = project;
    // Pre-formatted strings used in logs
    const fTargetMajor = highlight(`v${target.major}`);
    const fCurrentMajor = highlight(`v${current.major}`);
    const fTarget = version(target);
    const fCurrent = version(current);
    // Flags
    const isMajorUpgrade = target.major > current.major;
    // Handle potential major upgrade, warns, and asks for confirmation to proceed
    if (isMajorUpgrade) {
        options.logger.warn(`Detected a major upgrade for the "${highlight(ReleaseType.Latest)}" tag: ${fCurrent} > ${fTarget}`);
        // Find the latest release in between the current one and the next major
        const newerPackageRelease = npmPackage.findVersionsInRange(rangeFactory(`>${current.raw} <${target.major}`)).at(-1);
        // If the project isn't on the latest version for the current major, emit a warning
        if (newerPackageRelease) {
            const fLatest = version(semVerFactory(newerPackageRelease.version));
            options.logger.warn(`It's recommended to first upgrade to the latest version of ${fCurrentMajor} (${fLatest}) before upgrading to ${fTargetMajor}.`);
        }
        const proceedAnyway = await upgrader.confirm(`I know what I'm doing. Proceed anyway!`);
        if (!proceedAnyway) {
            throw new AbortedError();
        }
    }
};

const upgrade = async (options)=>{
    const timer = timerFactory();
    const { logger, codemodsTarget } = options;
    // Resolves the correct working directory based on the given input
    const cwd = path$1.resolve(options.cwd ?? process.cwd());
    const project = projectFactory(cwd);
    logger.debug(projectDetails(project));
    if (!isApplicationProject(project)) {
        throw new Error(`The "${options.target}" upgrade can only be run on a Strapi project; for plugins, please use "codemods".`);
    }
    logger.debug(`Application: VERSION=${version(project.packageJSON.version)}; STRAPI_VERSION=${version(project.strapiVersion)}`);
    const npmPackage = npmPackageFactory(STRAPI_PACKAGE_NAME);
    // Load all available versions from the NPM registry
    await npmPackage.refresh();
    // Initialize the upgrade instance
    // Throws during initialization if the provided target is incompatible with the current version
    const upgrader = upgraderFactory(project, options.target, npmPackage).dry(options.dry ?? false).onConfirm(options.confirm ?? null).setLogger(logger);
    // Manually override the target version for codemods if it's explicitly provided
    if (codemodsTarget !== undefined) {
        upgrader.overrideCodemodsTarget(codemodsTarget);
    }
    // Prompt user for confirmation details before upgrading
    await runUpgradePrompts(upgrader, options);
    // Add specific requirements before upgrading
    addUpgradeRequirements(upgrader, options);
    // Actually run the upgrade process once configured,
    // The response contains information about the final status: success/error
    const upgradeReport = await upgrader.upgrade();
    if (!upgradeReport.success) {
        throw upgradeReport.error;
    }
    timer.stop();
    logger.info(`Completed in ${durationMs(timer.elapsedMs)}ms`);
};
const runUpgradePrompts = async (upgrader, options)=>{
    if (options.target === ReleaseType.Latest) {
        await latest(upgrader, options);
    }
};
const addUpgradeRequirements = (upgrader, options)=>{
    // Don't add the same requirements when manually targeting a major upgrade
    // using a semver as it's implied that the users know what they're doing
    if (options.target === ReleaseType.Major) {
        upgrader.addRequirement(REQUIRE_AVAILABLE_NEXT_MAJOR).addRequirement(REQUIRE_LATEST_FOR_CURRENT_MAJOR);
    }
    // Make sure the git repository is in an optimal state before running the upgrade
    // Mainly used to ease rollbacks in case the upgrade is corrupted
    upgrader.addRequirement(REQUIRE_GIT.asOptional());
};

const resolvePath = (cwd)=>path$1.resolve(cwd ?? process.cwd());
const getRangeFromTarget = (currentVersion, target)=>{
    if (isSemverInstance(target)) {
        return rangeFactory(target);
    }
    const { major, minor, patch } = currentVersion;
    switch(target){
        case ReleaseType.Latest:
            throw new Error("Can't use <latest> to create a codemods range: not implemented");
        case ReleaseType.Major:
            return rangeFactory(`${major}`);
        case ReleaseType.Minor:
            return rangeFactory(`${major}.${minor}`);
        case ReleaseType.Patch:
            return rangeFactory(`${major}.${minor}.${patch}`);
        default:
            throw new Error(`Invalid target set: ${target}`);
    }
};
const findRangeFromTarget = (project, target)=>{
    // If a range is manually defined, use it
    if (isRangeInstance(target)) {
        return target;
    }
    // If the current project is a Strapi application
    // Get the range from the given target
    if (isApplicationProject(project)) {
        return getRangeFromTarget(project.strapiVersion, target);
    }
    // Else, if the project is a Strapi plugin or anything else
    // Set the range to match any version
    return rangeFactory('*');
};

const runCodemods = async (options)=>{
    const timer = timerFactory();
    const { logger, uid } = options;
    // Make sure we're resolving the correct working directory based on the given input
    const cwd = resolvePath(options.cwd);
    const project = projectFactory(cwd);
    const range = findRangeFromTarget(project, options.target);
    logger.debug(projectDetails(project));
    logger.debug(`Range: set to ${versionRange(range)}`);
    const codemodRunner = codemodRunnerFactory(project, range).dry(options.dry ?? false).onSelectCodemods(options.selectCodemods ?? null).setLogger(logger);
    let report;
    // If uid is defined, only run the selected codemod
    if (uid !== undefined) {
        logger.debug(`Running a single codemod: ${codemodUID(uid)}`);
        report = await codemodRunner.runByUID(uid);
    } else {
        report = await codemodRunner.run();
    }
    if (!report.success) {
        throw report.error;
    }
    timer.stop();
    logger.info(`Completed in ${timer.elapsedMs}`);
};

const listCodemods = async (options)=>{
    const { logger, target } = options;
    const cwd = resolvePath(options.cwd);
    const project = projectFactory(cwd);
    const range = findRangeFromTarget(project, target);
    logger.debug(projectDetails(project));
    logger.debug(`Range: set to ${versionRange(range)}`);
    // Create a codemod repository targeting the default location of the codemods
    const repo = codemodRepositoryFactory();
    // Make sure all the codemods are loaded
    repo.refresh();
    // Find groups of codemods matching the given range
    const groups = repo.find({
        range
    });
    // Flatten the groups into a simple codemod array
    const codemods = groups.flatMap((collection)=>collection.codemods);
    // Debug
    logger.debug(`Found ${highlight(codemods.length)} codemods`);
    // Don't log an empty table
    if (codemods.length === 0) {
        logger.info(`Found no codemods matching ${versionRange(range)}`);
        return;
    }
    // Format the list to a pretty table
    const fCodemods = codemodList(codemods);
    logger.raw(fCodemods);
};

class Logger {
    get isNotSilent() {
        return !this.isSilent;
    }
    get errors() {
        return this.nbErrorsCalls;
    }
    get warnings() {
        return this.nbWarningsCalls;
    }
    get stdout() {
        return this.isSilent ? undefined : process.stdout;
    }
    get stderr() {
        return this.isSilent ? undefined : process.stderr;
    }
    setDebug(debug) {
        this.isDebug = debug;
        return this;
    }
    setSilent(silent) {
        this.isSilent = silent;
        return this;
    }
    debug(...args) {
        const isDebugEnabled = this.isNotSilent && this.isDebug;
        if (isDebugEnabled) {
            console.log(chalk.cyan(`[DEBUG]\t[${nowAsISO()}]`), ...args);
        }
        return this;
    }
    error(...args) {
        this.nbErrorsCalls += 1;
        if (this.isNotSilent) {
            console.error(chalk.red(`[ERROR]\t[${nowAsISO()}]`), ...args);
        }
        return this;
    }
    info(...args) {
        if (this.isNotSilent) {
            console.info(chalk.blue(`[INFO]\t[${new Date().toISOString()}]`), ...args);
        }
        return this;
    }
    raw(...args) {
        if (this.isNotSilent) {
            console.log(...args);
        }
        return this;
    }
    warn(...args) {
        this.nbWarningsCalls += 1;
        if (this.isNotSilent) {
            console.warn(chalk.yellow(`[WARN]\t[${new Date().toISOString()}]`), ...args);
        }
        return this;
    }
    constructor(options = {}){
        // Set verbosity options
        this.isDebug = options.debug ?? false;
        this.isSilent = options.silent ?? false;
        // Initialize counters
        this.nbErrorsCalls = 0;
        this.nbWarningsCalls = 0;
    }
}
const nowAsISO = ()=>new Date().toISOString();
const loggerFactory = (options = {})=>new Logger(options);

export { codeRunnerFactory as A, jsonRunnerFactory as B, assertAppProject as C, assertPluginProject as D, constants$3 as E, isApplicationProject as F, isPluginProject as G, projectFactory as H, AbortedError as I, unknownToError as J, codemodFactory as K, constants$2 as L, codemodRepositoryFactory as M, NPMCandidateNotFoundError as N, constants$1 as O, constants as P, upgraderFactory as Q, requirementFactory as R, listCodemods as S, runCodemods as T, UnexpectedError as U, upgrade as V, loggerFactory as W, ReleaseType as X, codemodList as a, codemodUID as b, constants$4 as c, durationMs as d, projectDetails as e, projectType as f, transform as g, highlight as h, versionRange as i, types as j, isLiteralSemVer as k, isRangeInstance as l, isSemVerReleaseType as m, isSemverInstance as n, isValidSemVer as o, path as p, isValidStringifiedRange as q, reports as r, rangeFactory as s, timerFactory as t, upgradeStep as u, version as v, rangeFromReleaseType as w, rangeFromVersions as x, semVerFactory as y, fileScannerFactory as z };
//# sourceMappingURL=logger-np_r7rTc.mjs.map
