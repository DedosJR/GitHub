import os from 'os';
import chalk from 'chalk';
import { Option, InvalidArgumentError, program } from 'commander';
import prompts from 'prompts';
import { I as AbortedError, q as isValidStringifiedRange, s as rangeFactory, X as ReleaseType, k as isLiteralSemVer, y as semVerFactory, o as isValidSemVer, W as loggerFactory, V as upgrade$1, T as runCodemods$1, S as listCodemods$1 } from './chunks/logger-np_r7rTc.mjs';
import 'semver';
import 'cli-table3';
import 'node:path';
import 'node:assert';
import 'fs-extra';
import 'fast-glob';
import 'jscodeshift/src/Runner';
import 'lodash/fp';
import 'esbuild-register/dist/node';
import '@strapi/utils';
import 'simple-git';

const handleError = (err, isSilent)=>{
    // If the upgrade process has been aborted, exit silently
    if (err instanceof AbortedError) {
        process.exit(0);
    }
    if (!isSilent) {
        console.error(chalk.red(`[ERROR]\t[${new Date().toISOString()}]`), err instanceof Error ? err.message : err);
    }
    process.exit(1);
};

const projectPathOption = new Option('-p, --project-path <project-path>', 'Root path to the Strapi application or plugin');
const dryOption = new Option('-n, --dry', 'Simulate the upgrade without updating any files').default(false);
const debugOption = new Option('-d, --debug', 'Get more logs in debug mode').default(false);
const silentOption = new Option('-s, --silent', "Don't log anything").default(false);
const autoConfirmOption = new Option('-y, --yes', 'Automatically answer "yes" to any prompts that the CLI might print on the command line.').default(false);
const rangeOption = new Option('-r, --range <range>', 'Use a custom semver range for the codemods execution.').argParser((range)=>{
    if (!isValidStringifiedRange(range)) {
        throw new InvalidArgumentError('Expected a valid semver range');
    }
    return rangeFactory(range);
});

const upgrade = async (options)=>{
    try {
        const { silent, debug, yes } = options;
        const logger = loggerFactory({
            silent,
            debug
        });
        logger.warn("Please make sure you've created a backup of your codebase and files before upgrading");
        const confirm = async (message)=>{
            if (yes) {
                return true;
            }
            const { confirm } = await prompts({
                name: 'confirm',
                type: 'confirm',
                message
            });
            // If confirm is undefined (Ctrl + C), default to false
            return confirm ?? false;
        };
        await upgrade$1({
            logger,
            confirm,
            dry: options.dry,
            cwd: options.projectPath,
            target: options.target,
            codemodsTarget: options.codemodsTarget
        });
    } catch (err) {
        handleError(err, options.silent);
    }
};
/**
 * Registers upgrade related codemods.
 */ const register$1 = (program)=>{
    const addReleaseUpgradeCommand = (releaseType, description)=>{
        program.command(releaseType).description(description).addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(autoConfirmOption).action(async (options)=>{
            return upgrade({
                ...options,
                target: releaseType
            });
        });
    };
    // upgrade latest
    addReleaseUpgradeCommand(ReleaseType.Latest, 'Upgrade to the latest available version of Strapi');
    // upgrade major
    addReleaseUpgradeCommand(ReleaseType.Major, 'Upgrade to the next available major version of Strapi');
    // upgrade minor
    addReleaseUpgradeCommand(ReleaseType.Minor, 'Upgrade to the latest minor and patch version of Strapi for the current major');
    // upgrade patch
    addReleaseUpgradeCommand(ReleaseType.Patch, 'Upgrade to latest patch version of Strapi for the current major and minor');
    // upgrade to <target>
    program.command('to <target>', {
        hidden: true
    }).description('Upgrade to the specified version of Strapi').addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(autoConfirmOption).addOption(new Option('-c, --codemods-target <codemodsTarget>', 'Use a custom target for the codemods execution. Useful when targeting pre-releases').argParser((codemodsTarget)=>{
        if (!isLiteralSemVer(codemodsTarget)) {
            throw new InvalidArgumentError(`Expected a version with the following format: "<number>.<number>.<number>"`);
        }
        return semVerFactory(codemodsTarget);
    })).action(async (target, options)=>{
        if (!isValidSemVer(target)) {
            console.error(`Invalid target supplied, expected a valid semver but got "${target}"`);
            process.exit(1);
        }
        return upgrade({
            ...options,
            target: semVerFactory(target)
        });
    });
};

const DEFAULT_TARGET = ReleaseType.Major;
const runCodemods = async (options)=>{
    const { silent, debug } = options;
    const logger = loggerFactory({
        silent,
        debug
    });
    logger.warn("Please make sure you've created a backup of your codebase and files before running the codemods");
    const confirm = async (message)=>{
        const { confirm } = await prompts({
            name: 'confirm',
            type: 'confirm',
            message
        });
        // If confirm is undefined (Ctrl + C), default to false
        return confirm ?? false;
    };
    const selectCodemods = async (codemods)=>{
        const selectableCodemods = codemods.map(({ version, codemods })=>codemods.map((codemod)=>({
                    title: `(${version}) ${codemod.format()}`,
                    value: codemod,
                    selected: true
                }))).flat();
        if (selectableCodemods.length === 0) {
            logger.info('No codemods to run');
            return [];
        }
        const { selectedCodemods } = await prompts({
            type: 'autocompleteMultiselect',
            name: 'selectedCodemods',
            message: 'Choose the codemods you would like to run:',
            choices: selectableCodemods
        });
        if (!selectedCodemods || selectedCodemods.length === 0) {
            logger.info('No codemods selected');
            return [];
        }
        return selectedCodemods.map((codemod)=>({
                version: codemod.version,
                codemods: [
                    codemod
                ]
            }));
    };
    return runCodemods$1({
        logger,
        confirm,
        selectCodemods,
        dry: options.dry,
        cwd: options.projectPath,
        target: options.range ?? DEFAULT_TARGET,
        uid: options.uid
    }).catch((err)=>handleError(err, options.silent));
};
const listCodemods = async (options)=>{
    const { silent, debug } = options;
    const logger = loggerFactory({
        silent,
        debug
    });
    return listCodemods$1({
        cwd: options.projectPath,
        target: options.range ?? DEFAULT_TARGET,
        logger
    }).catch((err)=>handleError(err, options.silent));
};
/**
 * Registers codemods related commands.
 */ const register = (program)=>{
    const codemodsCommand = program.command('codemods');
    // upgrade codemods run [options] [uid]
    codemodsCommand.command('run [uid]').description(`
Executes a set of codemods on the current project.

If the optional UID argument is provided, the command specifically runs the codemod associated with that UID.
Without the UID, the command produces a list of all available codemods for your project.

By default, when executed on a Strapi application project, it offers codemods matching the current major version of the app.
When executed on a Strapi plugin project, it shows every codemods.
`).addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(rangeOption).action(async (uid, options)=>{
        return runCodemods({
            ...options,
            uid
        });
    });
    // upgrade codemods ls [options]
    codemodsCommand.command('ls').description(`List available codemods`).addOption(projectPathOption).addOption(debugOption).addOption(silentOption).addOption(rangeOption).action(async (options)=>{
        return listCodemods(options);
    });
};

var version = "5.10.4";

register$1(program);
register(program);
program.usage('<command> [options]').on('command:*', ([invalidCmd])=>{
    console.error(chalk.red(`[ERROR] Invalid command: ${invalidCmd}.${os.EOL} See --help for a list of available commands.`));
    process.exit(1);
}).helpOption('-h, --help', 'Print command line options').addHelpCommand('help [command]', 'Print options for a specific command').version(version).parse(process.argv);
//# sourceMappingURL=cli.mjs.map
