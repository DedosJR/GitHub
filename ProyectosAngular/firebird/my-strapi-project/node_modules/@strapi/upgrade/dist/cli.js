'use strict';

var os = require('os');
var chalk = require('chalk');
var commander = require('commander');
var prompts = require('prompts');
var logger = require('./chunks/logger-DGi224NW.js');
require('semver');
require('cli-table3');
require('node:path');
require('node:assert');
require('fs-extra');
require('fast-glob');
require('jscodeshift/src/Runner');
require('lodash/fp');
require('esbuild-register/dist/node');
require('@strapi/utils');
require('simple-git');

const handleError = (err, isSilent)=>{
    // If the upgrade process has been aborted, exit silently
    if (err instanceof logger.AbortedError) {
        process.exit(0);
    }
    if (!isSilent) {
        console.error(chalk.red(`[ERROR]\t[${new Date().toISOString()}]`), err instanceof Error ? err.message : err);
    }
    process.exit(1);
};

const projectPathOption = new commander.Option('-p, --project-path <project-path>', 'Root path to the Strapi application or plugin');
const dryOption = new commander.Option('-n, --dry', 'Simulate the upgrade without updating any files').default(false);
const debugOption = new commander.Option('-d, --debug', 'Get more logs in debug mode').default(false);
const silentOption = new commander.Option('-s, --silent', "Don't log anything").default(false);
const autoConfirmOption = new commander.Option('-y, --yes', 'Automatically answer "yes" to any prompts that the CLI might print on the command line.').default(false);
const rangeOption = new commander.Option('-r, --range <range>', 'Use a custom semver range for the codemods execution.').argParser((range)=>{
    if (!logger.isValidStringifiedRange(range)) {
        throw new commander.InvalidArgumentError('Expected a valid semver range');
    }
    return logger.rangeFactory(range);
});

const upgrade = async (options)=>{
    try {
        const { silent, debug, yes } = options;
        const logger$1 = logger.loggerFactory({
            silent,
            debug
        });
        logger$1.warn("Please make sure you've created a backup of your codebase and files before upgrading");
        const confirm = async (message)=>{
            if (yes) {
                return true;
            }
            const { confirm } = await prompts({
                name: 'confirm',
                type: 'confirm',
                message
            });
            // If confirm is undefined (Ctrl + C), default to false
            return confirm ?? false;
        };
        await logger.upgrade({
            logger: logger$1,
            confirm,
            dry: options.dry,
            cwd: options.projectPath,
            target: options.target,
            codemodsTarget: options.codemodsTarget
        });
    } catch (err) {
        handleError(err, options.silent);
    }
};
/**
 * Registers upgrade related codemods.
 */ const register$1 = (program)=>{
    const addReleaseUpgradeCommand = (releaseType, description)=>{
        program.command(releaseType).description(description).addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(autoConfirmOption).action(async (options)=>{
            return upgrade({
                ...options,
                target: releaseType
            });
        });
    };
    // upgrade latest
    addReleaseUpgradeCommand(logger.ReleaseType.Latest, 'Upgrade to the latest available version of Strapi');
    // upgrade major
    addReleaseUpgradeCommand(logger.ReleaseType.Major, 'Upgrade to the next available major version of Strapi');
    // upgrade minor
    addReleaseUpgradeCommand(logger.ReleaseType.Minor, 'Upgrade to the latest minor and patch version of Strapi for the current major');
    // upgrade patch
    addReleaseUpgradeCommand(logger.ReleaseType.Patch, 'Upgrade to latest patch version of Strapi for the current major and minor');
    // upgrade to <target>
    program.command('to <target>', {
        hidden: true
    }).description('Upgrade to the specified version of Strapi').addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(autoConfirmOption).addOption(new commander.Option('-c, --codemods-target <codemodsTarget>', 'Use a custom target for the codemods execution. Useful when targeting pre-releases').argParser((codemodsTarget)=>{
        if (!logger.isLiteralSemVer(codemodsTarget)) {
            throw new commander.InvalidArgumentError(`Expected a version with the following format: "<number>.<number>.<number>"`);
        }
        return logger.semVerFactory(codemodsTarget);
    })).action(async (target, options)=>{
        if (!logger.isValidSemVer(target)) {
            console.error(`Invalid target supplied, expected a valid semver but got "${target}"`);
            process.exit(1);
        }
        return upgrade({
            ...options,
            target: logger.semVerFactory(target)
        });
    });
};

const DEFAULT_TARGET = logger.ReleaseType.Major;
const runCodemods = async (options)=>{
    const { silent, debug } = options;
    const logger$1 = logger.loggerFactory({
        silent,
        debug
    });
    logger$1.warn("Please make sure you've created a backup of your codebase and files before running the codemods");
    const confirm = async (message)=>{
        const { confirm } = await prompts({
            name: 'confirm',
            type: 'confirm',
            message
        });
        // If confirm is undefined (Ctrl + C), default to false
        return confirm ?? false;
    };
    const selectCodemods = async (codemods)=>{
        const selectableCodemods = codemods.map(({ version, codemods })=>codemods.map((codemod)=>({
                    title: `(${version}) ${codemod.format()}`,
                    value: codemod,
                    selected: true
                }))).flat();
        if (selectableCodemods.length === 0) {
            logger$1.info('No codemods to run');
            return [];
        }
        const { selectedCodemods } = await prompts({
            type: 'autocompleteMultiselect',
            name: 'selectedCodemods',
            message: 'Choose the codemods you would like to run:',
            choices: selectableCodemods
        });
        if (!selectedCodemods || selectedCodemods.length === 0) {
            logger$1.info('No codemods selected');
            return [];
        }
        return selectedCodemods.map((codemod)=>({
                version: codemod.version,
                codemods: [
                    codemod
                ]
            }));
    };
    return logger.runCodemods({
        logger: logger$1,
        confirm,
        selectCodemods,
        dry: options.dry,
        cwd: options.projectPath,
        target: options.range ?? DEFAULT_TARGET,
        uid: options.uid
    }).catch((err)=>handleError(err, options.silent));
};
const listCodemods = async (options)=>{
    const { silent, debug } = options;
    const logger$1 = logger.loggerFactory({
        silent,
        debug
    });
    return logger.listCodemods({
        cwd: options.projectPath,
        target: options.range ?? DEFAULT_TARGET,
        logger: logger$1
    }).catch((err)=>handleError(err, options.silent));
};
/**
 * Registers codemods related commands.
 */ const register = (program)=>{
    const codemodsCommand = program.command('codemods');
    // upgrade codemods run [options] [uid]
    codemodsCommand.command('run [uid]').description(`
Executes a set of codemods on the current project.

If the optional UID argument is provided, the command specifically runs the codemod associated with that UID.
Without the UID, the command produces a list of all available codemods for your project.

By default, when executed on a Strapi application project, it offers codemods matching the current major version of the app.
When executed on a Strapi plugin project, it shows every codemods.
`).addOption(projectPathOption).addOption(dryOption).addOption(debugOption).addOption(silentOption).addOption(rangeOption).action(async (uid, options)=>{
        return runCodemods({
            ...options,
            uid
        });
    });
    // upgrade codemods ls [options]
    codemodsCommand.command('ls').description(`List available codemods`).addOption(projectPathOption).addOption(debugOption).addOption(silentOption).addOption(rangeOption).action(async (options)=>{
        return listCodemods(options);
    });
};

var version = "5.10.4";

register$1(commander.program);
register(commander.program);
commander.program.usage('<command> [options]').on('command:*', ([invalidCmd])=>{
    console.error(chalk.red(`[ERROR] Invalid command: ${invalidCmd}.${os.EOL} See --help for a list of available commands.`));
    process.exit(1);
}).helpOption('-h, --help', 'Print command line options').addHelpCommand('help [command]', 'Print options for a specific command').version(version).parse(process.argv);
//# sourceMappingURL=cli.js.map
